import React, {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
} from "react";
import { AuthClient } from "@dfinity/auth-client"; // DFINITY AuthClient for Internet Identity
import { Principal } from "@dfinity/principal"; // DFINITY Principal type
import { ActorSubclass } from "@dfinity/agent"; // DFINITY ActorSubclass type
// The 'declarations' folder will be generated by dfx deploy/generate
import type { _SERVICE } from "declarations/metasupply_backend/metasupply_backend.did"; // Use alias from tsconfig
import { canisterId as backendCanisterId } from "declarations/metasupply_backend"; // Use alias from tsconfig
import { createActor } from "../services/agent/agent"; // Import our custom actor creation utility

// Define the shape of the authentication context
interface AuthContextType {
  isAuthenticated: boolean; // Is the user currently authenticated?
  principal: Principal | null; // The user's Principal (their unique ID on the IC)
  authClient: AuthClient | null; // The AuthClient instance
  backendActor: ActorSubclass<_SERVICE> | null; // The actor instance for the backend canister
  login: () => Promise<void>; // Function to initiate login
  logout: () => Promise<void>; // Function to initiate logout
  isAuthReady: boolean; // Indicates if the initial authentication check is complete
}

// Create the AuthContext. It's initialized with `undefined` and will be provided by AuthProvider.
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// AuthProvider component to wrap your application and provide authentication state
export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ // <-- Ensure 'export' is here
  children,
}) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [principal, setPrincipal] = useState<Principal | null>(null);
  const [authClient, setAuthClient] = useState<AuthClient | null>(null);
  const [backendActor, setBackendActor] = useState<ActorSubclass<_SERVICE> | null>(null);
  const [isAuthReady, setIsAuthReady] = useState(false); // State to track if auth initialization is done

  // Callback function to initialize AuthClient and check authentication status
  const initAuth = useCallback(async () => {
    try {
      const client = await AuthClient.create(); // Create an AuthClient instance
      setAuthClient(client); // Store the client in state

      const authenticated = await client.isAuthenticated(); // Check if user is already authenticated
      setIsAuthenticated(authenticated); // Update isAuthenticated state

      if (authenticated) {
        const identity = client.getIdentity(); // Get the user's identity
        const userPrincipal = identity.getPrincipal(); // Get the user's Principal
        setPrincipal(userPrincipal); // Store the principal in state
        // Create backend actor using the authenticated identity
        setBackendActor(createActor(backendCanisterId, identity));
      } else {
        // If not authenticated, clear principal and actor
        setPrincipal(null);
        setBackendActor(null);
      }
    } catch (error) {
      console.error("Error initializing AuthClient:", error);
      // Reset states on error
      setIsAuthenticated(false);
      setPrincipal(null);
      setBackendActor(null);
    } finally {
      setIsAuthReady(true); // Mark auth initialization as complete
    }
  }, []); // Empty dependency array means this function is created once

  // Effect hook to run initAuth when the component mounts
  useEffect(() => {
    initAuth();
  }, [initAuth]); // `initAuth` is a dependency because it's a useCallback

  // Handle user login via Internet Identity
  const login = useCallback(async () => {
    if (!authClient) {
      console.error("AuthClient not initialized.");
      return;
    }

    try {
      await authClient.login({
        // Determine the identity provider URL based on the DFX_NETWORK environment variable
        identityProvider:
          process.env.DFX_NETWORK === "ic"
            ? "https://identity.ic0.app/#authorize" // Official Internet Identity for mainnet
            : `http://localhost:4943/?canisterId=${process.env.CANISTER_ID_INTERNET_IDENTITY}#authorize`, // Local Internet Identity
        onSuccess: async () => {
          await initAuth(); // Re-initialize auth state after successful login to get new identity
        },
        onError: (error) => {
          console.error("Internet Identity login failed:", error);
        },
      });
    } catch (error) {
      console.error("Error during login process:", error);
    }
  }, [authClient, initAuth]); // Dependencies for the login function

  // Handle user logout
  const logout = useCallback(async () => {
    if (!authClient) {
      console.error("AuthClient not initialized.");
      return;
    }

    try {
      await authClient.logout(); // Perform logout
      // Reset states after logout
      setIsAuthenticated(false);
      setPrincipal(null);
      setBackendActor(null);
      console.log("Logged out successfully.");
    } catch (error) {
      console.error("Error during logout:", error);
    }
  }, [authClient]); // Dependency for the logout function

  // Value object to be provided by the context
  const value = {
    isAuthenticated,
    principal,
    authClient,
    backendActor,
    login,
    logout,
    isAuthReady,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Custom hook to easily consume the AuthContext in any child component
export const useAuth = () => { // <-- Ensure 'export' is here
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
